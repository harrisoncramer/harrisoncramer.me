---
title: Terminal Applications in Go
pubDate: 2024-08-22
description: Charm's BubbleTea library makes works well with Cobra for building powerful command line tooling for developers
heroImage: snake
imageDescription: An image of a snake wrapped around a tree branch
slug: nested-models-with-charm
tags: ["go", "terminal"]
---

What makes good developer tooling? A few things jump to mind:

- It is fast
- It's easy to deploy/use in different environments
- It's well documented
- It's flexible and configurable, and preferably supports scripting and automation

Considering all of these factors, CLIs (Command Line Interfaces) are arguably the most effective developer tooling out there. As text and keyboard-based tools, CLIs are _far better_ than their GUI counterparts at scripting and automation. Tooling that embraces the [linux philosophy](https://en.wikipedia.org/wiki/Unix_philosophy) is by nature extensible and modular.

All that being said, CLIs are not always approachable for new users. They're designed to pipe data from one tool to another, not necessarily to hold application state and display options to an indecisive user, who may just be trying to explore the tool.

This is where TUIs, or Terminal User Interfaces, are a relatively interesting middle ground. 

While they live in the terminal, they're more akin to traditional GUI applications in that they display state and respond to user interactions. In fact, by combining CLIs and TUIs we can get the best of both worlds -- powerful scripting and automatation capabilities, user-friendliness, and state management!

## What are we building?

This post shows how to build a simple and configurable terminal application with Go for interacting with ChatGPT. 

The tool uses [Cobra](https://github.com/spf13/cobra) to set up the command, [Viper](https://github.com/spf13/viper) to load and manage the tool's configuration, and [Bubbletea](https://github.com/charmbracelet/bubbletea) to build the UI. The tools and strategies used here can be extended to build terminal applications of all kinds.

## Setting up with Cobra and Viper ðŸ

Our `main.go` file is very bare bones, as per Cobra's recommendation.

```go title="main.go"
package main

import (
	cmd "github.com/harrisoncramer/my-gpt/cmd"
)

func main() {
	cmd.Execute()
}
```

In our `cmd/root.go` file, we'll set flag options (in this case a `token` option and a `config` option). When our root command is called, the `cmd` struct is passed as an argument to another function called `initializeConfig` which parses our configuration for the application.

```go {22} title="cmd/root.go" 
package cmd

import (
	"fmt"
	"os"

	app "github.com/harrisoncramer/my-gpt/app"
	"github.com/spf13/cobra"
)

/* The init() function is called automatically by Go */
func init() {
	rootCmd.PersistentFlags().StringP("token", "t", "", "The API token used to communicate with ChatGPT")
	rootCmd.PersistentFlags().StringP("config", "", "", "The path to a .yaml configuration file, by default the current directory")
}

/* Set up the command. Right now, there's just one, the root command */
var rootCmd = &cobra.Command{
	Use:   "my-gpt",
	Short: "A TUI for interacting with ChatGPT from the command line",
	Run: func(cmd *cobra.Command, args []string) {
		err := initializeConfig(cmd)
		if err != nil {
			fmt.Printf("Error configuring application: %v", err)
			os.Exit(1)
		}

		app.Start()
	},
}

func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}
```

I've put the `initializeConfig` function into a separate file called `config.go`. This function loads a YAML file, and unpacks it into the application. Rather than loading and parsing the YAML with a typical reader, we use [Viper](https://github.com/spf13/viper). The library lets use easily set default values, hot reload our configuration when the yaml changes, and has other benefits.

```go title="cmd/config.go"
package cmd

import (
	"fmt"

	app "github.com/harrisoncramer/my-gpt/app"
	"github.com/harrisoncramer/my-gpt/shared"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

/* Sets the default configuration options, then reads in the config file into our app */
func initializeConfig(cmd *cobra.Command) error {
	p := shared.PluginOpts{}
	viper.SetConfigName("config")
	viper.SetConfigType("yaml")
	viper.SetDefault("display.cursor", ">")
	viper.SetDefault("network.timeout", 2000)
	viper.SetDefault("keys.up", "k")
	viper.SetDefault("keys.down", "j")
	viper.SetDefault("keys.select", "enter")
	viper.SetDefault("keys.quit", "ctrl+c")
	viper.SetDefault("keys.back", "esc")
	viper.BindPFlag("token", cmd.PersistentFlags().Lookup("token"))

	/* Look for config file in current directory by default */
	configFile, _ := cmd.Flags().GetString("config")
	if configFile == "" {
		configFile = "."
	}
	viper.AddConfigPath(configFile)
	err := viper.ReadInConfig()

	if err != nil {
		return fmt.Errorf("Fatal error reading configuration file: %v", err)
	}

	if err := viper.Unmarshal(&p); err != nil {
		return fmt.Errorf("Fatal error unmarshalling configuration file: %v", err)
	}

  /* Set the config optios on our app */
	app.PluginOptions = p
	return nil
}
```

The `shared` package at this point just contains one file, which includes our type for our plugin options:

```go title="shared/types.go"
package shared

/* The options for the plugin, read into the application by Viper from a YAML file */
type PluginOpts struct {
	Token   string      `mapstructure:"token"`
	Network NetworkOpts `mapstructure:"network"`
	Display DisplayOpts `mapstructure:"display"`
	Keys    KeyOpts     `mapstructure:"keys"`
}

type NetworkOpts struct {
	Timeout int `mapstructure:"timeout"`
}

type KeyOpts struct {
	Up     string `mapstructure:"up"`
	Down   string `mapstructure:"down"`
	Select string `mapstructure:"select"`
	Back   string `mapstructure:"back"`
	Quit   string `mapstructure:"quit"`
}

type DisplayOpts struct {
	Cursor string `mapstructure:"cursor"`
}
```

And our `app` module, for now, just contains a global variable called `PluginOptions`

```go
package app

import (
	"fmt"
	"github.com/harrisoncramer/my-gpt/shared"
)

/* Global plugin options shared across models */
var PluginOptions shared.PluginOpts

func Start() {
  fmt.Printf("%+v", PluginOptions)
}
```

If all goes well, when we run our application:

1. The Cobra tool will run our root command
2. The Viper code will read in our config file, and set missing default values
4. Viper will set the configuration in our app package
3. The app package will start, and print out the configuration

Let's make a `config.yaml` file in the root of the repository with some settings: 

```yaml title="config.yaml"
token: "blah"
display:
  cursor: ">>"
network:
  timeout: 1000
keys:
  select: "o"
```

And then let's run our application!

```bash
$ go run . --config ./config.yaml
{Token:blah Network:{Timeout:1000 TimeoutMillis:1s} Display:{Cursor:>>} Keys:{Up:k Down:j Select:o Back:esc Quit:ctrl+c}}
```

As you can see, the values from our YAML file are being parsed into the application. We can override the token if we want by passing in a `--token` flag.

Thanks to Cobra, we can also see more about our application by running the `--help` command.

```bash
$ go run . --config ./config.yaml --help
Our TUI application

Usage:
  sh [flags]

Flags:
      --config string   The path to a .yaml configuration file
  -h, --help            help for sh
  -t, --token token     Token for the Shortcut API. This value will override a token set in your config file
```

## The Basic Model with BubbleTea ðŸ§‹
