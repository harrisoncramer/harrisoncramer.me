---
title: Terminal Applications in Go
pubDate: 2024-08-22
description: Charm's BubbleTea library makes works well with Cobra for building powerful command line tooling for developers
heroImage: snake
imageDescription: An image of a snake wrapped around a tree branch
slug: nested-models-with-charm
tags: ["go", "terminal"]
---

What makes good developer tooling? A few things jump to mind:

- It is fast
- It's easy to deploy/use in different environments
- It's well documented
- It's flexible and configurable, and preferably supports scripting and automation

Considering all of these factors, CLIs (Command Line Interfaces) are arguably the most effective developer tooling out there. As text and keyboard-based tools, CLIs are _far better_ than their GUI counterparts at scripting and automation. Tooling that embraces the [linux philosophy](https://en.wikipedia.org/wiki/Unix_philosophy) is by nature extensible and modular.

All that being said, CLIs are not always approachable for new users. They're designed to pipe data from one tool to another, not necessarily to hold application state and display options to an indecisive user, who may just be trying to explore the tool.

This is where TUIs, or Terminal User Interfaces, are a relatively interesting middle ground. 

While they live in the terminal, they're more akin to traditional GUI applications in that they display state and respond to user interactions. In fact, by combining CLIs and TUIs we can get the best of both worlds -- powerful scripting and automatation capabilities, user-friendliness, and state management!

## What are we building?

This post shows how to build a simple and configurable terminal application with Go for interacting with ChatGPT. The application will present us with a list of choices, and allow us to send our choice to ChatGPT, which will then return an answer to the prompt.

The tool uses [Cobra](https://github.com/spf13/cobra) to set up the command, [Viper](https://github.com/spf13/viper) to load and manage the tool's configuration, and [Bubbletea](https://github.com/charmbracelet/bubbletea) to build the UI. The tools and strategies used here can be extended to build terminal applications of all kinds.

## Setting up with Cobra and Viper ðŸ

Initialize your module first!

```bash
mkdir my-gpt && cd my-gpt
go mod init
touch main.go
```

Our `main.go` file is very bare bones, as per Cobra's recommendation.

```go title="main.go"
package main

import (
	cmd "github.com/harrisoncramer/my-gpt/cmd"
)

func main() {
	cmd.Execute()
}
```

In our `cmd/root.go` file, we'll set flag options (in this case a `token` option and a `config` option). When our root command is called, the `cmd` struct is passed as an argument to another function called `initializeConfig` which parses our configuration for the application.

```go {22} title="cmd/root.go" 
package cmd

import (
	"fmt"
	"os"

	app "github.com/harrisoncramer/my-gpt/app"
	"github.com/spf13/cobra"
)

/* The init() function is called automatically by Go */
func init() {
	rootCmd.PersistentFlags().StringP("token", "t", "", "The API token used to communicate with ChatGPT")
	rootCmd.PersistentFlags().StringP("config", "", "", "The path to a .yaml configuration file, by default the current directory")
}

/* Set up the command. Right now, there's just one, the root command */
var rootCmd = &cobra.Command{
	Use:   "my-gpt",
	Short: "A TUI for interacting with ChatGPT from the command line",
	Run: func(cmd *cobra.Command, args []string) {
		err := initializeConfig(cmd)
		if err != nil {
			fmt.Printf("Error configuring application: %v", err)
			os.Exit(1)
		}

		app.Start()
	},
}

func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}
```

I've put the `initializeConfig` function into a separate file called `config.go`. This function loads a YAML file, and unpacks it into the application. Rather than loading and parsing the YAML with a typical reader, we use [Viper](https://github.com/spf13/viper). The library lets use easily set default values, hot reload our configuration when the yaml changes, and has other benefits.

```go title="cmd/config.go"
package cmd

import (
	"fmt"

	app "github.com/harrisoncramer/my-gpt/app"
	"github.com/harrisoncramer/my-gpt/shared"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

/* Sets the default configuration options, then reads in the config file into our app */
func initializeConfig(cmd *cobra.Command) error {
	p := shared.PluginOpts{}
	viper.SetConfigName("config")
	viper.SetConfigType("yaml")
	viper.SetDefault("display.cursor", ">")
	viper.SetDefault("network.timeout", 2000)
	viper.SetDefault("keys.up", "k")
	viper.SetDefault("keys.down", "j")
	viper.SetDefault("keys.select", "enter")
	viper.SetDefault("keys.quit", "ctrl+c")
	viper.SetDefault("keys.back", "esc")
	viper.BindPFlag("token", cmd.PersistentFlags().Lookup("token"))

	/* Look for config file in current directory by default */
	configFile, _ := cmd.Flags().GetString("config")
	if configFile == "" {
		configFile = "."
	}
	viper.AddConfigPath(configFile)
	err := viper.ReadInConfig()

	if err != nil {
		return fmt.Errorf("Fatal error reading configuration file: %v", err)
	}

	if err := viper.Unmarshal(&p); err != nil {
		return fmt.Errorf("Fatal error unmarshalling configuration file: %v", err)
	}

  /* Set the config optios on our app */
	app.PluginOptions = p
	return nil
}
```

The `shared` package at this point just contains one file, which includes our type for our plugin options:

```go title="shared/types.go"
package shared

/* The options for the plugin, read into the application by Viper from a YAML file */
type PluginOpts struct {
	Token   string      `mapstructure:"token"`
	Network NetworkOpts `mapstructure:"network"`
	Display DisplayOpts `mapstructure:"display"`
	Keys    KeyOpts     `mapstructure:"keys"`
}

type NetworkOpts struct {
	Timeout int `mapstructure:"timeout"`
}

type KeyOpts struct {
	Up     string `mapstructure:"up"`
	Down   string `mapstructure:"down"`
	Select string `mapstructure:"select"`
	Back   string `mapstructure:"back"`
	Quit   string `mapstructure:"quit"`
}

type DisplayOpts struct {
	Cursor string `mapstructure:"cursor"`
}
```

And our `app` module, for now, just contains a global variable called `PluginOptions`

```go
package app

import (
	"fmt"
	"github.com/harrisoncramer/my-gpt/shared"
)

/* Global plugin options shared across models */
var PluginOptions shared.PluginOpts

func Start() {
  fmt.Printf("%+v", PluginOptions)
}
```

If all goes well, when we run our application:

1. The Cobra tool will run our root command
2. The Viper code will read in our config file, and set missing default values
4. Viper will set the configuration in our app package
3. The app package will start, and print out the configuration

Let's make a `config.yaml` file in the root of the repository with some settings: 

```yaml title="config.yaml"
token: "blah"
display:
  cursor: ">>"
network:
  timeout: 1000
keys:
  select: "o"
```

And then let's run our application!

```bash
$ go run . --config ./config.yaml
{Token:blah Network:{Timeout:1000 TimeoutMillis:1s} Display:{Cursor:>>} Keys:{Up:k Down:j Select:o Back:esc Quit:ctrl+c}}
```

As you can see, the values from our YAML file are being parsed into the application. We can override the token if we want by passing in a `--token` flag. Thanks to Cobra, we can also see more about our application by running the `--help` command.

```bash
$ go run . --config ./config.yaml --help
Our TUI application

Usage:
  sh [flags]

Flags:
      --config string   The path to a .yaml configuration file
  -h, --help            help for sh
  -t, --token token     Token for the ChatGPT API. This value will override a token set in your config file
```

Now that we've got our CLI configured, let's work on building our stateful application.

## The Basic Model with BubbleTea ðŸ§‹

BubbleTea uses an MVC pattern to control state and render views. I'd recommend familiarizing yourself with it and [Elm's model](https://guide.elm-lang.org/architecture/) for application architecture, on which BubbleTea is based.

To start, let's update our `Start` function so that it actually starts our application:

```go {16-21} title="app/main.go"
package app

import (
	"fmt"
	"os"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/harrisoncramer/my-gpt/shared"
)

/* Global plugin options shared across models */
var PluginOptions shared.PluginOpts

/* Initializes the root model and starts the TUI application */
func Start() {
	m := NewFirstModel()
	p := tea.NewProgram(m)
	if _, err := p.Run(); err != nil {
		fmt.Printf("Error starting BubbleTea: %v", err)
		os.Exit(1)
	}
}
```

We now need to define our BubbleTea model.

The model can only be passed to `tea.NewProgram` when it has a set of methods: `Init`, `Update`, and `View`. These methods satisfy BubbleTea's `tea.Model` interface.

When our model first starts, it calls the `Init` function. The function is responsible for any initial work, such as reaching out to APIs or setting initial data in our model. The application then enters an update cycle.

The cycle responds to events (like a keypress or a window resize event) via the `Update` method. These events are passed as `tea.Msg` arguments to the method. The method takes these messages and modifies our application state (and possibly returns more commands, which will re-trigger the update cycle). 

Finally, the `View` function is responsible for taking our model's state and rendering the view, which is just a string.

Let's set up the methods to satisfy that interface. 

Our `Init` method is a no-op. 

Our `View` method will simply return our application's plugin options in a readable form. 

Our `Update` method will switch on the message type, and for keypresses that match our keybinding for quit, will return a `tea.Quit` command. The `tea.Quit` command is a command provided by BubbleTea that will exit the application.

```go title="app/main_model.go"
package app

import (
	tea "github.com/charmbracelet/bubbletea"
)

func NewFirstModel() tea.Model {
	return MainModel{}
}

type MainModel struct {}

func (m Model) Init() tea.Cmd {
	return nil
}

func (m MainModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case PluginOptions.Keys.Quit:
			return m, tea.Quit
		}
	}

	return m, nil
}

func (m Model) View() string {
  return fmt.Sprintf("%+v", PluginOptions)
}
```

Now, when we run our application, we should see the application load and display our configuration. Pressing our quit key (by default `ctrl+c`) will exit the application.

## Building a Selector Component

Since we are building an application that allows us to choose from a set of options, we want to give the user the ability to scroll between the options, and choose one.

While we could handle this in the parent model, BubbleTea encourages the use of nested models for these types of behaviors. When the main model encounters an event that should be handled by a subview, it'll delegate the `Update` behavior to that submodel.

In our main model, let's embed another `tea.Model` called `selector` which is also a tea model.

```go {9-20, 25} title="app/main_model.go"
package app

import (
	tea "github.com/charmbracelet/bubbletea"
)

func NewFirstModel() tea.Model {
	return MainModel{
		selector: Selector{
			options: []Option{
				{
					Label: "View Config",
					Value: "view_config",
				},
				{
					Label: "Second",
					Value: "second",
				},
			},
		},
	}
}

type MainModel struct {
	selector Selector
}


func (m Model) Init() tea.Cmd {
	return nil
}

func (m MainModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case PluginOptions.Keys.Quit:
			return m, tea.Quit
		}
	}

	return m, nil
}

func (m Model) View() string {
  return fmt.Sprintf("%+v", PluginOptions)
}
```

I'm putting the `Selector` model into a different file. This model handles a set of keypresses, and updates it's internal state accordingly. It'll render a set of choices.

The `move` function invocations in the `Update` function mutate the model's state. 

There is also behavior defined for when the select key is pressed. In that case, we return a new command (Commands in BubbleTea are just functions that return messages) which will be handled by the parent.

```go {47,49,51,70-91} title="app/selector.go"
package app

import (
	"fmt"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
)

type Option struct {
	Label string `json:"label"`
	Value string `json:"value"`
}

type Selector struct {
	cursor  int
	options []Option
}

type Direction string

const (
	Up   Direction = "up"
	Down Direction = "down"
)

type moveMsg struct {
	direction Direction
}

type selectMsg struct {
	value string
}

func (s Selector) Init() tea.Cmd {
	return nil
}

/* Responds to keypresses that are defined in our plugin options and updates the model */
func (s Selector) Update(msg tea.Msg) (Selector, tea.Cmd) {
	switch msg := msg.(type) {
	case optionsMsg:
		s.setOptions(msg.options)
	case tea.KeyMsg:
		switch msg.String() {
		case PluginOptions.Keys.Down:
			s.move(Down)
		case PluginOptions.Keys.Up:
			s.move(Up)
		case PluginOptions.Keys.Select:
			return s, s.selectVal
		}
	}
	return s, nil
}

/* Renders the choices and the current cursor */
func (s Selector) View() string {
	base := ""
	for i, option := range s.options {
		if i == s.cursor {
			base += fmt.Sprintf("%s %s\n", PluginOptions.Display.Cursor, option.Label)
		} else {
			base += fmt.Sprintf("%s %s\n", strings.Repeat(" ", len(PluginOptions.Display.Cursor)), option.Label)
		}
	}
	return base
}

/* Moves the cursor up or down among the options */
func (s *Selector) move(direction Direction) {
	if direction == Up {
		if s.cursor > 0 {
			s.cursor--
		}
	} else {
		if s.cursor < len(s.options)-1 {
			s.cursor++
		}
	}
}

/* Sets options on the selector */
func (s *Selector) setOptions(options []Option) {
	s.options = options
}

/* Chooses the value at the given index. This message is processed by the main model. */
func (s Selector) selectVal() tea.Msg {
	return selectMsg{value: s.options[s.cursor].Value}
}
```

Now that we've built and defined our model, we need to wire it up to our parent component. We need to:

1. Call the `Update` method on the selector when a relevant key is pressed
2. Handle any messages triggered by the child component
3. Call the `View` method to render the selector, then combine this text with our parent's view

#### Calling the Selector's `Update` method

Let's tackle the `Update` function first. There are multiple ways to do this. I like defining an additional method on the selector called `maybeUpdate` which will update the component _only if_ a key is pressed. Define the method on your selector model:

```go title="app/selector.go"
/* Rest of model cropped for brevity ... */

func (s Selector) maybeUpdate(msg tea.Msg) (Selector, tea.Cmd) {
	switch msg := msg.(type) {
	case optionsMsg, moveMsg:
		return s.Update(msg)
	case tea.KeyMsg:
		switch msg.String() {
		case PluginOptions.Keys.Down, PluginOptions.Keys.Up, PluginOptions.Keys.Select:
			return s.Update(msg)
		}
	}

	return s, nil
}
```

This method will call the actual `Update` method. I like this pattern because it encapsulates all of the selector logic in one place. Now, we can call `maybeUpdate` in our parent model for every event.

```go title="app/main.go"
func (m MainModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {

	/* Possibly update the selector. If the selectorCmd 
    is non-null it means that our selector's Update method was called,
    we want to return that command and re-run our event loop */
	updatedSelector, selectorCmd := m.selector.maybeUpdate(msg)
	m.selector = updatedSelector
	if selectorCmd != nil {
		return m, selectorCmd
	}

	switch msg := msg.(type) {
	/* ...all other events */
```

#### Handling Messages from the Selector

Next, we need to tell the main model how to respond to messages triggered by the selector component.

In our case, there's only one message type we need to care about: `selectMsg`. We can use type descrimination to react accordingly. For now, we'll just exit the application with a message.


```go {17-19} title="app/main.go"
func (m MainModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	if m.err != nil {
		return m, tea.Quit
	}

	updatedSelector, selectorCmd := m.selector.maybeUpdate(msg)
	m.selector = updatedSelector
	if selectorCmd != nil {
		return m, selectorCmd
	}

	/* All other events */
	switch msg := msg.(type) {
	case errMsg:
		m.err = msg
		return m, nil
	case selectMsg:
      log.Fatal(fmt.Sprintf("You chose %s", msg.value))
      os.Exit(0)
	case tea.KeyMsg:
		switch msg.String() {
		case PluginOptions.Keys.Quit:
			return m, tea.Quit
		}
	}
```

#### Rendering our Full View

The last piece we need to wire up is our view. Right now, our selector's state is updating but we aren't displaying it.

All we need to do is call the `View` method and combine it with our parent's view. Update your main model's `View` method accordingly:

```go
/* Rest of model cropped for brevity... */

func (m MainModel) View() string {
	base := "Main View\n"
	base += m.selector.View()
	base += fmt.Sprintf("\n\n%s", m.help.View(m.keys))
	return base
}
```

At this point, we should be able to navigate up and down in our view, and make a selection. The selection should print out to the screen and then quit our application. This may seem like a lot of code for such a simple application. It is! But the foundation for more complexity is now in place. Let's handle that next.

## Calling ChatGPT and Handling Latency
