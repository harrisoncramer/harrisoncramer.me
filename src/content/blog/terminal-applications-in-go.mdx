---
title: Terminal Applications in Go
pubDate: 2024-08-22
description: Charm's BubbleTea library makes works well with Cobra for building powerful command line tooling for developers
heroImage: snake
imageDescription: An image of a snake wrapped around a tree branch
slug: nested-models-with-charm
tags: ["go", "terminal"]
---

What makes good developer tooling? A few things jump to mind:

- It is fast
- It's easy to deploy/use in different environments
- It's well documented
- It's flexible and configurable, and preferably supports scripting and automation

Considering all of these factors, CLIs (Command Line Interfaces) are arguably the most effective developer tooling out there. As text and keyboard-based tools, CLIs are _far better_ than their GUI counterparts at scripting and automation. Tooling that embraces the [linux philosophy](https://en.wikipedia.org/wiki/Unix_philosophy) is by nature extensible and modular.

All that being said, CLIs are not always approachable for new users. They're designed to pipe data from one tool to another, not necessarily to hold application state and display options to an indecisive user, who may just be trying to explore the tool.

This is where TUIs, or Terminal User Interfaces, are a relatively interesting middle ground. 

While they live in the terminal, they're more akin to traditional GUI applications in that they display state and respond to user interactions. In fact, by combining CLIs and TUIs we can get the best of both worlds -- powerful scripting and automatation capabilities, user-friendliness, and state management!

## What are we building?

This post shows how to build a simple and configurable terminal application with Go. I'm using [cobra](https://github.com/spf13/cobra) to parse command options and set up the tool, and [bubbletea](https://github.com/charmbracelet/bubbletea) to build the UI.

## Setting up the Tool with Cobra 🐍

Our `main.go` file is very bare bones, as per Cobra's recommendation.

```go title="main.go"
package main

import (
	cmd "github.com/harrisoncramer/nested-models/cmd"
)

func main() {
	cmd.Execute()
}
```

Then in our `cmd/root.go` file, we'll set flag options (in this case a `token` option and a `config` option). The command is then passed as an argument to another function called `initializeConfig` which parses out the values.

```go title="cmd/root.go"
package cmd

import (
	"fmt"
	"os"

	app "github.com/harrisoncramer/nested-models/app"
	"github.com/spf13/cobra"
)

/* The init() function is called automatically by Go */
func init() {
	rootCmd.PersistentFlags().StringP("token", "t", "", "The API token used to communicate with ChatGPT")
	rootCmd.PersistentFlags().StringP("config", "", "", "The path to a .yaml configuration file, by default the current directory")
}

/* Set up the command. Right now, there's just one, the root command */
var rootCmd = &cobra.Command{
	Use:   "sh",
	Short: "A TUI for interacting with ChatGPT from the command line",
	Run: func(cmd *cobra.Command, args []string) {
		err := initializeConfig(cmd)
		if err != nil {
			fmt.Printf("Error configuring application: %v", err)
			os.Exit(1)
		}

		app.Start()
	},
}

func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}
```

I've put the `initializeConfig` function into a separate file called `config.go` which parses out the options from the YAML file, and unpacks them into the application. Rather than loading and parsing the YAML directly, this function uses [viper](https://github.com/spf13/viper) which lets us elegantly set defaults, allows hot-reloading on configuration changes, and has other benefits.

```go title="cmd/config.go"
package cmd

import (
	"fmt"

	app "github.com/harrisoncramer/nested-models/app"
	"github.com/harrisoncramer/nested-models/shared"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

/* Sets default configuration options then reads in the configuration file and sets it in the app */
func initializeConfig(cmd *cobra.Command) error {
	p := shared.PluginOpts{}
	viper.SetConfigName("config")
	viper.SetConfigType("yaml")
	viper.SetDefault("display.cursor", ">")
	viper.SetDefault("network.timeout", 2000)
	viper.SetDefault("keys.up", "k")
	viper.SetDefault("keys.down", "j")
	viper.SetDefault("keys.select", "enter")
	viper.SetDefault("keys.quit", "ctrl+c")
	viper.SetDefault("keys.back", "esc")
	viper.BindPFlag("token", cmd.PersistentFlags().Lookup("token"))

	/* Look for config file in current directory by default */
	configFile, _ := cmd.Flags().GetString("config")
	if configFile == "" {
		configFile = "."
	}
	viper.AddConfigPath(configFile)
	err := viper.ReadInConfig()

	if err != nil {
		return fmt.Errorf("Fatal error reading configuration file: %v", err)
	}

	if err := viper.Unmarshal(&p); err != nil {
		return fmt.Errorf("Fatal error unmarshalling configuration file: %v", err)
	}

	app.PluginOptions = p
	return nil
}
```

Finally, we need to create our app code, that 

At this point, we should be good to run the application. Let's make a `config.yaml` file in the root of the repository with some settings: 

```yaml title="config.yaml"
token: "blah"
display:
  cursor: ">>"
network:
  timeout: 1000
keys:
  select: "o"
```

And then let's run our application:

```bash
$ go run . --config ./config.yaml
{Token:blah Network:{Timeout:1000 TimeoutMillis:1s} Display:{Cursor:>>} Keys:{Up:k Down:j Select:o Back:esc Quit:ctrl+c}}
```

As you can see, the values from our YAML file are being parsed into the application. We can also override the authorization token if we want by passing in a `--token` flag.

We can also see more about our application by running the `--help` command.

```bash
$ go run . --config ./config.yaml --help
Our TUI application

Usage:
  sh [flags]

Flags:
      --config string   The path to a .yaml configuration file
  -h, --help            help for sh
  -t, --token token     Token for the Shortcut API. This value will override a token set in your config file
```
