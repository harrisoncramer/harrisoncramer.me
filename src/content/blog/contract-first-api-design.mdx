---
title: Contract-First API Design
pubDate: 2024-08-15
description: Comparing different approaches to modeling state and enforcing schemas across API boundaries
imageDescription: A variety of signs in a crowded downtown neighborhood.
heroImage: contract
tags: ["typescript", "javascript", "api", "go"]
slug: contract-first-api-design.mdx
---

One point of friction that often slows down engineering teams is a misunderstanding about API contracts.

Whether it's hotels or online dating, as engineering teams learn more about the domain they're working in, they'll need to adjust parts of the application's data model. Sometimes, this is to correct misconceptions that they originally baked into their APIs. Other times, it's to add new areas of the domain to that they haven't encountered before.

Bit by bit, the team's original mental model of the domain will shift, especially as APIs are deprecated or become bloated with old data.
 
When this happens, having a shared API contract across the engineering team is very valuable. 

As requirements change and the application grows, the contract serves as a guidepost for engineers on both sides of the stack.

This blog outlines three possible approaches to enforcing and sharing a schema in order to enforce consistency in API design.

## OpenAPI and Code Generation

Swagger, recently renamed to OpenAPI, is an [open source API specification](https://swagger.io/specification/).

When building contract-driven APIs, engineers may write these contracts first, often as YAML or JSON, before implementing them in code.

By implementing the contracts first, engineers can then use those contracts to generate common boilerplate and validation logic. This lets the team focus on implementing the correct business logic instead. 

These API contract files can also be used to generate tests and enable cross-language type safety.

### When to Use It

### When not to Use It

## TRPC

### When to Use It

### When not to Use It

## JSON Schema

### When to Use It

### When not to Use It
