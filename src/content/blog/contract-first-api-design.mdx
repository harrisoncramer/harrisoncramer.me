---
title: Contract-First API Design
pubDate: 2024-08-15
description: Comparing different approaches to modeling state and enforcing schemas across API boundaries
imageDescription: A variety of signs in a crowded downtown neighborhood.
heroImage: contract
tags: ["typescript", "javascript", "api", "go"]
slug: contract-first-api-design.mdx
---

One point of friction that often slows down engineering teams is a misunderstanding about API contracts.

Whether it's hotels or online dating, as engineering teams learn more about the domain they're working in, they'll need to adjust parts of the application's data model. Sometimes, this is to correct misconceptions that they originally baked into their APIs. Other times, it's to add new areas of the domain to that they haven't encountered before.

Bit by bit, the team's original mental model of the domain will shift, especially as APIs are deprecated or become bloated with old data.
 
When this happens, having a shared API contract across the engineering team is very valuable. 

As requirements change and the application grows, the contract serves as a guidepost for engineers on both sides of the stack.

This blog outlines three possible approaches to enforcing and sharing a schema in order to enforce consistency in API design.

## OpenAPI (aka Swagger)

Swagger, recently renamed to OpenAPI, is an [open source API specification](https://swagger.io/specification/).

When using OpenAPI, engineers can write these contract documents first, often as YAML or JSON, before implementing them in code.

This lets engineers use those contracts in code generation tools to build common boilerplate, validation middleware, cross-langauge type safety, and tests. It also frees engineers to focus the application's business logic.

In a full-stack Typescript application, a contract for a users endpoint might look like this:

```yaml
openapi: 3.0.0
info:
  title: Typescript Full Stack OpenAPI Template
  version: 0.0.1
paths:
  /api/v1/users/{userId}:
    get:
      summary: Get a user by their ID
      parameters:
      - in: path
        name: userId
        schema:
          type: integer
        required: true
        description: Numeric ID of the user
      responses:
        '200':
          description: A JSON object of a single user
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
  /api/v1/users:
    get:
      summary: Returns a list of users.
      responses:
        '200':
          description: A JSON array of user names
          content:
            application/json:
              schema: 
                type: array
                items:
                  $ref: '#/components/schemas/User'
components:
  schemas:
    User:
      type: object
      required:
        - id
        - first_name
        - last_name
      properties:
        first_name:
          type: string
        last_name:
          type: string
        id:
          type: number
```

This schema can then be fed into a code generation tool like [openapi-ts](https://github.com/hey-api/openapi-ts) to generate clients automatically. The types generated by this library can also be shared across the stack.

For instance, here is part of the automatically generated `types.gen.ts` file from running `openapi-ts` to build the application:

```typescript
export type User = {
    first_name: string;
    last_name: string;
    id: number;
};

export type GetApiV1UsersByUserIdResponse = User;
```

These types can be used across the stack to improve developer tooling. This tool can also generate client code directly, like this:

```typescript
import { getApiV1Users } from "@/api"
const { data } = await getApiV1Users()
```

In this example, the `data` variable is explicitly typed as `GetApiV1UsersByUserIdResponse` from the generated types.

On the server, we can use a library like [express-openapi-validator](https://cdimascio.github.io/express-openapi-validator-documentation/) to validate that our API responses conform to this schema:

```typescript
import * as OpenApiValidator from 'express-openapi-validator'
import { fileURLToPath } from 'url'
import path from 'path'

const __filename = fileURLToPath(import.meta.url)
const spec = path.join(path.dirname(__filename), '..', 'api.yaml')

export default OpenApiValidator.middleware({
  apiSpec: spec,
  validateRequests: true,
  validateResponses: true,
})
```

This code will show a validation error when a response has an invalida status code, includes data that does not match our schema, and so fortmatch our schema, and so forth.

### When to Use It

The OpenAPI specification and tooling around it is very stable and it's a great choice. Many different languages have libraries that can interface with OpenAPI specifications and generate code from it.

It's also a great choice if you expect the application's APIs to be exposed externally and need to provide documentation automatically.

### When not to Use It

If you are working purely in one language, writing YAML or JSON directly instead of types directly in the language of choice can feel clunky. In Typescript, for instance, there are schema-first alternatives like TRPC that may provide a better developer experience.

This is what we'll get into next.

## TRPC

TRPC, or TypeScript remote procedure call, is a newer technology than OpenAPI, and a good option for engineering teams that are working exclusively in Typescript and want to define their API contracts in the same language.

Like other RPCs, this tooling defines contracts at the method level, rather than in an external schema file like OpenAPI.

This makes the developer tooling top notch, as TPRC integrates seamlessly in real-time (no build step) with LSPs and other editor tools. This can make iterating on API designs faster than when using an OpenAPI specification.

To use TRPC, set up a schema file to define the API contract:

### When to Use It

### When not to Use It

You don't want to define the source of truth in Typescript, and prefer to use YAML or JSON for it's language-agnostic flexibility.

## JSON Schema

### When to Use It

### When not to Use It
